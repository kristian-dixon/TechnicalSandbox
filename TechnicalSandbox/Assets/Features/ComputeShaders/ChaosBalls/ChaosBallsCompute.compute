// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSPhysicsSim

struct Ball
{
    float2 position;
    float2 velocity;
};

float gravityStrength;
float deltaTime;
int textureSize;


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Trails;
RWTexture2D<float4> Result;

RWStructuredBuffer<Ball> balls;


[numthreads(64, 1, 1)]
void CSPhysicsSim(uint3 id : SV_DispatchThreadID)
{
    Ball ball = balls[id.x];

    balls[id.x].velocity += float2(0, gravityStrength * deltaTime);

    float2 newPosition = ball.position + ball.velocity * deltaTime;
    
    if (length(newPosition) < 1)
    {
        balls[id.x].position = newPosition;
    }
    else
    {
        balls[id.x].velocity = reflect(ball.velocity, normalize(-newPosition)) * 1.0025;
    }

    float2 ballUV = (balls[id.x].position * textureSize * 0.5) + 0.5 * float2(textureSize, textureSize);
    
    Trails[ballUV.xy] = float4(1, 0, 0, 0);

}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float2 uv = id.xy / (float) textureSize;
    uv *= 2.;
    uv -= 1;

    float3 colour = float3(1, 1, 1); //float3(0, 0, 0);
    colour *= smoothstep(0.99, 1, length(uv));

    

    Result[id.xy] = Trails[id.xy] + float4(colour, 1);
    float4 trails = Trails[id.xy] * 0.99;
    Trails[id.xy] = trails * step(0.2, length(trails));

}
