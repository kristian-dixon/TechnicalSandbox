#pragma kernel CSMain

struct Vertex
{
    float3 position;
    int lookupValue;
};

/*struct TableLookup
{
    int entry[16];
};*/


AppendStructuredBuffer<Vertex> appendBuffer;
//StructuredBuffer<TableLookup> lookupTable;

//Buffer<float3> cubePoints;

float size;
float width;
int cubeType;

//For now 1==inside volume 0 == outside
int Map(uint3 id)
{
    if(id.x == 0 || id.y == 0 || id.z == 0 || id.x >= width || id.y >= width || id.z >= width )
    {
        return 0;
    }
    
    int val = step(id.y, width / 2.0f);
    
    val *= 1 - step(length(id - float3(width / 2, width / 2, width / 2)), 5);
    
    
    return val;
}

int SampleVolume(uint3 id)
{
    int val = Map(id);
    val += Map(id + uint3(1, 0, 0)) * 2;
    val += Map(id + uint3(1, 0, 1)) * 4;
    val += Map(id + uint3(0, 0, 1)) * 8;
    
    val += Map(id + uint3(0, 1, 0)) * 16;
    val += Map(id + uint3(1, 1, 0)) * 32;
    val += Map(id + uint3(1, 1, 1)) * 64;
    val += Map(id + uint3(0, 1, 1)) * 128;
    //
    return val;
}

[numthreads(8, 8, 8)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    //if (id.x == 4 && id.y == 6 && id.z == 3)
    {
    //Normalize pos
        float3 pos = id / (width - 1);

    //make pos range from -size to +size
        pos = (pos - 0.5) * 2.0 * size;
   
        int lookupVal = SampleVolume(id);
        Vertex v1;
        v1.position = pos; // + float3(0, id.z * 10, 0);
        v1.lookupValue = lookupVal;
        appendBuffer.Append(v1);
    }
}