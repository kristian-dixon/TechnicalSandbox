#pragma kernel GenerateVolume
#pragma kernel GenerateMesh

//Volume generation
RWTexture3D<float> VolumeTexture;
float4 chunkPosition;
float cubeSize;
int resolution;

[numthreads(8,8,8)]
void GenerateVolume (uint3 id : SV_DispatchThreadID)
{
    if(max(id.x, max(id.y, id.z)) > resolution) return;

    float3 worldPosition = chunkPosition.xyz + (id) * cubeSize;
    VolumeTexture[id.xyz] = worldPosition.y + sin(worldPosition.x * 0.2562f) * 5.0f + sin(worldPosition.z * 0.3562f) * 5.0f;
}


//Volume -> mesh generation

struct OutputTriangle{
    float3 positionA;
    float3 positionB;
    float3 positionC;
};

struct IndirectArgs{
    uint numVertsPerInst;
    uint numInst;
    uint startVert;
    uint startInst;
};

AppendStructuredBuffer<OutputTriangle> _OutputTriangleBuffer;
RWStructuredBuffer<IndirectArgs> _IndirectArgsBuffer;

StructuredBuffer<int> _CubeConfigurations;
StructuredBuffer<float3> _VertexLayouts;

int GetIndex(uint3 id, uint length){
    return id.x + id.y * length + id.z * length * length;
}

[numthreads(4,4,4)]
void GenerateMesh(uint3 id : SV_DispatchThreadID){
    //if(max(id.x, max(id.y, id.z)) > resolution) return;
    if(max(id.x, max(id.y, id.z)) >= resolution - 1){
        return;                                           
    }

    int idx = GetIndex(id, resolution);
    
    //Calculate bitfield value
    int bitfieldVal = 0;
    
    
    int marchingKernel[8] = {
        1,2,16,32,8,4,128,64
    }; 
    
    //marchingKernel[0, 0, 0] = 1; 
    //marchingKernel[1, 0, 0] = 2; 
    //marchingKernel[0, 1, 0] = 16; 
    //marchingKernel[1, 1, 0] = 32; 
    //marchingKernel[0, 0, 1] = 8;
    //marchingKernel[1, 0, 1] = 4; 
    //marchingKernel[0, 1, 1] = 128;    
    //marchingKernel[1, 1, 1] = 64; 
    for(int x = 0; x < 2; x++)
    {
        for(int y = 0; y < 2; y++)
        {
            for(int z = 0; z < 2; z++)
            {
                uint3 cellId = uint3(x,y,z);
            
                //Get noise value
                float noiseVal = VolumeTexture[cellId + id];
                if(noiseVal < 0.2)
                {
                    bitfieldVal += marchingKernel[GetIndex(cellId, 2)];
                }
            }
        }
    }
    
    float3 localPosition = cubeSize * id;
    
    int configurationId = bitfieldVal * 16;
    //Use bitfield val to access configuration & build mesh
    for(int i = 0; i < 16; i+=3)
    {
        int configIndex = _CubeConfigurations[i + configurationId];
        if(configIndex == -1) return;
        
        OutputTriangle output = (OutputTriangle)0;
        output.positionA = localPosition + _VertexLayouts[_CubeConfigurations[i + configurationId]];
        output.positionB = localPosition + _VertexLayouts[_CubeConfigurations[i + configurationId + 1]];
        output.positionC = localPosition + _VertexLayouts[_CubeConfigurations[i + configurationId + 2]];
    
        _OutputTriangleBuffer.Append(output);
        InterlockedAdd(_IndirectArgsBuffer[0].numVertsPerInst, 3);
    }
}