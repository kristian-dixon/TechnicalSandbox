#pragma kernel GenerateVolume
#pragma kernel GenerateMesh
#pragma kernel MeshPaint
#pragma kernel Consume

//Volume generation
RWTexture3D<float> VolumeTexture;
float4 chunkPosition;
float cubeSize;
int resolution;


float random (in float2 st) {
    return frac(sin(dot(st.xy,
                         float2(12.9898,78.233)))*
        43758.5453123);
}

// Based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in float2 st) {
    float2 i = floor(st);
    float2 f = frac(st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + float2(1.0, 0.0));
    float c = random(i + float2(0.0, 1.0));
    float d = random(i + float2(1.0, 1.0));

    float2 u = f * f * (3.0 - 2.0 * f);

    return lerp(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

#define OCTAVES 6
float fbm (in float2 st) {
    // Initial values
    float value = 0.0;
    float amplitude = .5;
    float frequency = 0.;
    //
    // Loop of octaves
    for (int i = 0; i < OCTAVES; i++) {
        value += amplitude * noise(st);
        st *= 2.;
        amplitude *= .5;
    }
    return value * 2.0 - 1.0;
}

float fbm3D (in float3 st) {
    
    return (fbm(st.xy) + fbm(st.zy + float2(32.52,76.21)) + fbm(st.zx + float2(92.52,26.21)) + fbm(st.xz + float2(12.52,26.21))) / 4.0;
}



[numthreads(8,8,8)]
void GenerateVolume (uint3 id : SV_DispatchThreadID)
{
    if(max(id.x, max(id.y, id.z)) > resolution) return;

    float3 worldPosition = chunkPosition.xyz + (id) * cubeSize;
    
    //float x = worldPosition.x;
    //x = worldPosition.x + fbm((worldPosition.xy ) * 0.1) * 4;
    //float volume = worldPosition.y + fbm(float2(x, worldPosition.z) * 0.05) * 10.0;
    
    float volume = worldPosition.y;
    
    worldPosition.x += fbm3D(worldPosition.yzx * .05) * 100; 
    worldPosition.z += fbm3D(worldPosition.zyx * .05) * 100; 
    
    volume += ((pow(fbm3D(worldPosition * .01), 5) * 100));//; + (fbm3D(worldPosition.zyx * .1) * 10) + (fbm3D(worldPosition * 1.96 * 0.49) * 0.25));//(fbm3D((worldPosition + float3(1351,761,671)) * 0.05) * 10.0);
    
    VolumeTexture[id.xyz] = volume;
}

float BrushStrength;
float BrushRadius;
float3 BrushPosition;


[numthreads(8,8,8)]
void MeshPaint (uint3 id : SV_DispatchThreadID)
{
    if(max(id.x, max(id.y, id.z)) > resolution) return;

    float3 worldPosition = chunkPosition.xyz + (id) * cubeSize;
    
    float mask = step(BrushRadius, distance(worldPosition, BrushPosition));//(max((BrushRadius - distance(worldPosition, BrushPosition)), 0) / BrushRadius) * 
    
    if(mask < 0.5)
        VolumeTexture[id.xyz] = BrushStrength;
    
}



//Volume -> mesh generation

struct OutputTriangle{
    float3 positionA;
    float3 positionB;
    float3 positionC;
};

struct IndirectArgs{
    uint numVertsPerInst;
    uint numInst;
    uint startVert;
    uint startInst;
};

AppendStructuredBuffer<OutputTriangle> _OutputTriangleBuffer;
RWStructuredBuffer<IndirectArgs> _IndirectArgsBuffer;

StructuredBuffer<int> _CubeConfigurations;
StructuredBuffer<float3> _VertexLayouts;

int GetIndex(uint3 id, uint length){
    return id.x + id.y * length + id.z * length * length;
}

[numthreads(8,8,8)]
void GenerateMesh(uint3 id : SV_DispatchThreadID){
    //if(max(id.x, max(id.y, id.z)) > resolution) return;
    if(max(id.x, max(id.y, id.z)) >= resolution - 1){
        return;                                           
    }

    int idx = GetIndex(id, resolution);
    
    //Calculate bitfield value
    int bitfieldVal = 0;
    
    
    int marchingKernel[8] = {
        1,2,16,32,8,4,128,64
    }; 
    
    //marchingKernel[0, 0, 0] = 1; 
    //marchingKernel[1, 0, 0] = 2; 
    //marchingKernel[0, 1, 0] = 16; 
    //marchingKernel[1, 1, 0] = 32; 
    //marchingKernel[0, 0, 1] = 8;
    //marchingKernel[1, 0, 1] = 4; 
    //marchingKernel[0, 1, 1] = 128;    
    //marchingKernel[1, 1, 1] = 64; 
    for(int x = 0; x < 2; x++)
    {
        for(int y = 0; y < 2; y++)
        {
            for(int z = 0; z < 2; z++)
            {
                uint3 cellId = uint3(x,y,z);
            
                //Get noise value
                float noiseVal = VolumeTexture[cellId + id];
                if(noiseVal < 0.2)
                {
                    bitfieldVal += marchingKernel[GetIndex(cellId, 2)];
                }
            }
        }
    }
    
    float3 localPosition = cubeSize * id;
    
    int configurationId = bitfieldVal * 16;
    //Use bitfield val to access configuration & build mesh
    for(int i = 0; i < 16; i+=3)
    {
        int configIndex = _CubeConfigurations[i + configurationId];
        if(configIndex == -1) return;
        
        OutputTriangle output = (OutputTriangle)0;
        output.positionA = localPosition + _VertexLayouts[_CubeConfigurations[i + configurationId]];
        float3 gridPos = (output.positionA + chunkPosition.xyz) * 0.05;
        output.positionA += float3(fbm(gridPos.xy + gridPos.yx + gridPos.zz), fbm(gridPos.zx + gridPos.yz + gridPos.yx), fbm(gridPos.yz + gridPos.zx + gridPos.zy)) * 4;
        
        output.positionB = localPosition + _VertexLayouts[_CubeConfigurations[i + configurationId + 1]];
        gridPos = (output.positionB + chunkPosition.xyz) * 0.05;
        output.positionB += float3(fbm(gridPos.xy + gridPos.yx + gridPos.zz), fbm(gridPos.zx + gridPos.yz + gridPos.yx), fbm(gridPos.yz + gridPos.zx + gridPos.zy)) * 4;
        
        output.positionC = localPosition + _VertexLayouts[_CubeConfigurations[i + configurationId + 2]];
        gridPos = (output.positionC + chunkPosition.xyz) * 0.05;
        output.positionC += float3(fbm(gridPos.xy + gridPos.yx + gridPos.zz), fbm(gridPos.zx + gridPos.yz + gridPos.yx), fbm(gridPos.yz + gridPos.zx + gridPos.zy)) * 4;
    
        _OutputTriangleBuffer.Append(output);
        InterlockedAdd(_IndirectArgsBuffer[0].numVertsPerInst, 3);
    }
}


int vertexCount;

ConsumeStructuredBuffer<OutputTriangle> _ConsumeBuffer;

[numthreads(32,1,1)]
void Consume(uint3 id : SV_DispatchThreadID)
{
    if(id.x < vertexCount){
        _ConsumeBuffer.Consume();
    }
}